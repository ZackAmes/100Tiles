
// Generated by dojo-bindgen on Wed, 7 Aug 2024 18:34:25 +0000. Do not modify this file manually.
// Import the necessary types from the recs SDK
// generate again with `sozo build --typescript` 
import { Account, byteArray } from "starknet";
import { DojoProvider } from "@dojoengine/core";
import * as models from "./models.gen";

export type IWorld = Awaited<ReturnType<typeof setupWorld>>;

export async function setupWorld(provider: DojoProvider) {
    // System definitions for `ok-matchmaking` contract
    function matchmaking() {
        const contract_name = "matchmaking";

        
        // Call the `world` system with the specified Account and calldata
        const world = async (props: { account: Account }) => {
            try {
                return await provider.execute(
                    props.account,
                    {
                        contractName: contract_name,
                        entrypoint: "world",
                        calldata: [],
                    },
                    "ok"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `create_game` system with the specified Account and calldata
        const create_game = async (props: { account: Account }) => {
            try {
                return await provider.execute(
                    props.account,
                    {
                        contractName: contract_name,
                        entrypoint: "create_game",
                        calldata: [],
                    },
                    "ok"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `join_game` system with the specified Account and calldata
        const join_game = async (props: { account: Account, game_id: number }) => {
            try {
                return await provider.execute(
                    props.account,
                    {
                        contractName: contract_name,
                        entrypoint: "join_game",
                        calldata: [props.game_id],
                    },
                    "ok"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `start_game` system with the specified Account and calldata
        const start_game = async (props: { account: Account, game_id: number }) => {
            try {
                return await provider.execute(
                    props.account,
                    {
                        contractName: contract_name,
                        entrypoint: "start_game",
                        calldata: [props.game_id],
                    },
                    "ok"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

        return {
            world, create_game, join_game, start_game
        };
    }

    // System definitions for `ok-actions` contract
    function actions() {
        const contract_name = "actions";

        
        // Call the `world` system with the specified Account and calldata
        const world = async (props: { account: Account }) => {
            try {
                return await provider.execute(
                    props.account,
                    {
                        contractName: contract_name,
                        entrypoint: "world",
                        calldata: [],
                    },
                    "ok"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `move` system with the specified Account and calldata
        const move = async (props: { account: Account, game_id: number }) => {
            try {
                return await provider.execute(
                    props.account,
                    {
                        contractName: contract_name,
                        entrypoint: "move",
                        calldata: [props.game_id],
                    },
                    "ok"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `resolve_turn` system with the specified Account and calldata
        const resolve_turn = async (props: { account: Account, game_id: number }) => {
            try {
                return await provider.execute(
                    props.account,
                    {
                        contractName: contract_name,
                        entrypoint: "resolve_turn",
                        calldata: [props.game_id],
                    },
                    "ok"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `set_pending_effect` system with the specified Account and calldata
        const set_pending_effect = async (props: { account: Account, game_id: number, direction: boolean, amt: number }) => {
            try {
                return await provider.execute(
                    props.account,
                    {
                        contractName: contract_name,
                        entrypoint: "set_pending_effect",
                        calldata: [props.game_id,
                props.direction,
                props.amt],
                    },
                    "ok"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

        return {
            world, move, resolve_turn, set_pending_effect
        };
    }

    return {
        matchmaking: matchmaking(),
        actions: actions()
    };
}
